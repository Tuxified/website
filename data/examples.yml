---
- title: Hello, World!
  code: |
    ```inko
    import std::stdio::stdout

    stdout.print('Hello, world!')
    ```
- title: Process communication
  code: |
    ```inko
    import std::process
    import std::stdio::stdout

    let proc = process.spawn {
      # This will print "Hello" to STDOUT.
      match(let message = process.receive) {
        as String -> { stdout.print(message) }
        else -> {}
      }
    }

    proc.send('Hello')
    ```

- title: Generic types
  code: |
    ```inko
    object List!(T) {
      @values: Array!(T)

      static def new -> Self {
        Self { @values = Array.new }
      }

      def push(value: T) -> T {
        @values.push(value)
      }
    }

    let list = List.new

    # This is OK:
    list.push(10)

    # This will produce a type error:
    list.push('oops')
    ```

- title: Error handling
  code: |
    ```inko
    import std::stdio::stderr

    def withdraw(euros: Integer) !! String {
      euros.negative?.if_true {
        throw 'Invalid number of Euros!'
      }
    }

    # "withdraw" might throw, so we must use the
    # "try" keyword
    try withdraw(euros: 5)

    # We can also handle the error, if needed:
    try {
      withdraw(euros: 5)
    } else (error) {
      stderr.print(error.message)
    }

    # "try!" terminates the program upon
    # encountering an error:
    try! withdraw(euros: 5)
    ```

- title: Reading from a file
  code: |
    ```inko
    import std::fs::file
    import std::stdio::stdout

    let txt_file = try! file.read_only('text.txt')
    let content = try! txt_file.read_string

    stdout.print(content)
    ```

- title: Type safe file operations
  code: |
    ```inko
    import std::fs::file

    let readme =
      try! file.read_only('README.md')

    # This will produce a type error, since
    # the file is opened in read-only mode.
    readme.write_string('oops')

    # This also won't work, because we can
    # not remove a read-only file.
    readme.remove
    ```

- title: Unit testing
  code: |
    ```inko
    import std::test
    import std::test::assert

    test.group('Integer.+') do (group) {
      group.test('Summing two Integers') {
        assert.equal(1 + 2, 3)
      }
    }

    test.run
    ```

- title: Implementing traits
  code: |
    ```inko
    import std::conversion::ToString
    import std::stdio::stdout

    object Person {
      @name: String

      static def new(name: String) -> Self {
        Self { @name = name }
      }
    }

    impl ToString for Person {
      def to_string -> String {
        @name
      }
    }

    let person = Person.new('Alice')

    # This will print "Alice" to STDOUT:
    stdout.print(person)
    ```

- title: Handling optional values
  code: |
    ```inko
    let numbers = Array.new(10, 20, 30)

    # Array.get() returns an Option type.
    numbers
      .get(2)
      .map do (n) { n.to_string } # => Some("30")
    ```

- title: Factorial
  code: |
    ```inko
    # Inko guarantees tail call elimination for
    # tail recursive methods, so this method
    # doesn't overflow the stack.
    def fact(num: Integer, acc = 1) -> Integer {
      # This returns from the surrounding method.
      num.zero?.if_true { return acc }

      fact(num - 1, acc * num)
    }

    fact(15) # => 1307674368000
    ```

- title: Loops
  code: |
    ```inko
    import std::stdio::stdout

    let mut number = 0

    while({ number < 10 }) {
      stdout.print('This loop will run 10 times')
      number += 1
    }

    loop {
      stdout.print('This is an infinite loop.')
    }
    ```

- title: Iterating over collections
  code: |
    ```inko
    import std::stdio::stdout

    let numbers = Array.new(10, 20, 30)

    # "each" allows us to easily iterate over
    # a collection:
    numbers.each do (number) {
      stdout.print(number)
    }

    # Using "iter" we can obtain an external,
    # composable iterator:
    let new_numbers = numbers
      .iter
      .map do (num) { num * 2 }
      .to_array

    new_numbers # => Array.new(20, 40, 60)
    ```

- title: Generators
  code: |
    ```inko
    # This method yields values of type Integer
    def numbers => Integer {
      yield 10
      yield 20
    }

    let generator = numbers

    generator.resume # => Some(10)
    generator.resume # => Some(20)
    generator.resume # => None
    ```
- title: Pattern matching expressions
  code: |
    ```inko
    def example(number: Integer) -> String {
      match(number) {
        1..10 -> { 'Yes!' }
        20 -> { 'Oh no!' }
        else -> { 'The number is not supported' }
      }
    }

    example(10) # => 'Yes!'
    example(20) # => 'Oh no!'
    example(50) # => 'The number is not supported'
    ```
- title: Pattern matching types
  code: |
    ```inko
    def example(type: Any) -> String {
      match(type) {
        as String -> { 'A String' }
        as Integer -> { 'An Integer' }
        else -> { 'Something else' }
      }
    }

    example('foo') # => 'A String'
    example(10)    # => 'An Integer'
    ```
- title: TCP sockets
  code: |
    ```inko
    import std::net::socket::TcpListener
    import std::net::socket::TcpStream
    import std::stdio::stdout

    let listener = try! TcpListener
      .new(ip: '127.0.0.1', port: 40_000)

    let stream = try! TcpStream
      .new(ip: '127.0.0.1', port: 40_000)

    try! stream.write_string('hello')

    stream.close

    let connection = try! listener.accept
    let output = try! connection.read_string

    connection.close
    listener.close

    stdout.print(output) # => 'hello'
    ```
