# Concurrent programming
# A concurrent/async generic stack.
class async Stack[T] {
  let @values: Array[uni T]

  fn static new -> Self {
    Self { @values = recover [] }
  }

  fn async mut push(value: uni T) {
    @values.push(value)
  }

  fn async mut pop -> uni Option[T] {
    if let Some(v) = @values.pop {
      recover Option.Some(v)
    } else {
      recover Option.None
    }
  }
}

fn main {
  # This is valid, as a few builtin types (e.g. Int
  # and String) are cheap to copy, so we don't have
  # to explicitly turn them into unique/sendable
  # values.
  Stack.new.push(42)

  # For more complex types, we do need to turn them
  # into unique values explicitly.
  let stack = Stack.new

  stack.push(recover [10, 20, 30])

  # The default approach to sending a message is to
  # wait for the result immediately. If we instead
  # want a future to resolve later, we do so using
  # `async` expressions:
  let future =
    async stack.pop # => Future[uni Array[Int]]

  future.await # => uni Array[Int]
}
