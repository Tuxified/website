# Concurrent programming
# A concurrent/async generic stack.
class async Stack[T] {
  let @values: Array[uni T]

  fn static new -> Self {
    Self { @values = recover [] }
  }

  fn async mut push(value: uni T) {
    @values.push(value)
  }

  fn async mut pop -> uni Option[T] {
    if let Some(v) = @values.pop {
      recover Option.Some(v)
    } else {
      recover Option.None
    }
  }
}

class async Main {
  fn async main {
    let stack = Stack.new

    # These are async calls/messages, and the sender waits
    # for the result of each call.
    stack.push(10)
    stack.push(20)
    stack.pop # => 20

    # And if we don't want to wait:
    let future = async stack.pop # => Future[Int, Never]

    future.await # => 10
  }
}
